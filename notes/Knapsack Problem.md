[TOC]

# 背包问题

## 1. 0-1背包问题（每种物品至多1个）

问题描述：一共有 N 件物品，第 i（i从1开始）件物品的重量为 w[i] ，价值为 v[i] 。在总重量不超过背包承载上限 W 的情况下，能够装入背包的最大价值是多少？

定义状态：`dp[i][j]`表示将前 i 件装入重量为 j 的背包中时的最大价值，其中`0<=i<=N, 0<=j<=W`

初始化：`dp[0][0,...,W] = 0`

状态转移方程：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i])`

优化：由于`dp[i][j]`只与`dp[i-1][0,...,j]`有关，采用滚动数组对空间进行优化（去掉 dp 的第一维）。为了防止上一层循环的 `dp[0,...j-1]`被覆盖，需要逆向枚举。

伪代码：
```
dp[0,...,W] = 0;
for i = 1,...N
    for j = W,...,W[i]
        dp[j] = max(dp[j], dp[j-w[i]]+v[i])
```

## 2. 完全背包问题（每种物品可以无限多个）(e.g. 0322)

问题描述：一共有 N 种物品，每种物品有无限多个，第 i（i从1开始）种物品的重量为 w[i]，价值为 v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？

定义状态：`dp[i][j]`表示将前 i 种装入重量为 j 的背包中时的最大价值，其中`0<=i<=N, 0<=j<=W`

初始化：`dp[0][0,...,W] = 0`

状态转移方程：`dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]]+v[i])`

优化：由于`dp[i][j]`只与`dp[i-1][0,...,j]`有关，采用滚动数组对空间进行优化（去掉 dp 的第一维）。需要正向枚举。

伪代码：
```
dp[0,...,W] = 0;
for i = 1,...N
    for j = W[i],...,W
        dp[j] = max(dp[j], dp[j-w[i]]+v[i])
```

## 3. 多重背包问题（每种物品至多有限个）

问题描述：一共有 N 种物品，第 i（i从1开始）种物品的数量为 n[i]，重量为 w[i]，价值为 v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？

定义状态：`dp[i][j]`表示将前 i 种装入重量为 j 的背包中时的最大价值，其中`0<=i<=N, 0<=j<=W`

初始化：`dp[0][0,...,W] = 0`

状态转移方程：`dp[i][j] = max{dp[i-1][j-k*w[i]]+k*v[i] for every k}, k <= min(n[i],j/w[i])`

优化：由于`dp[i][j]`只与`dp[i-1][0,...,j]`有关，采用滚动数组对空间进行优化（去掉 dp 的第一维）。需要逆向枚举。

伪代码：
```
dp[0,...,W] = 0;
for i = 1,...N
    for j = W,...,W[i]
        for k = 0,...,min(n[i],j/w[i]) 
            dp[j] = max(dp[j], dp[j-w[i]]+v[i])
```